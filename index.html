<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pivot Irrifrance</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        #map { height: 100vh; }
        #weather-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 30px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="weather-panel">Chargement météo...</div>
    <script>
        let map, weatherPanel, coords;

        // Fonction pour obtenir les paramètres d'URL
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            const values = params.get('p')?.split(',').map(Number); // Récupère et divise les valeurs

            return values && values.length === 12 ? {
                LatOri: values[0],
                LonOri: values[1],
                LatZero: values[2],
                LonZero: values[3],
                LatMaxAngle: values[4],
                LonMaxAngle: values[5],
                LatPiv: values[6],
                LonPiv: values[7],
                PivCirc: values[8],
                sens: values[9],
                lang: values[10],
                ang: values[11]
            } : null;
        }

        // Fonction pour initialiser la carte et l'affichage
        function initMap() {
            coords = getQueryParams();
            if (!coords) {
                alert('Paramètres d\'URL incorrects.');
                return;
            }

            map = L.map('map').setView([coords.LatOri, coords.LonOri], 16);

            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '© Esri, Maxar, Earthstar Geographics'
            }).addTo(map);

            weatherPanel = document.getElementById('weather-panel');

            // Définition des points à afficher sur la carte
            const points = {
                origine: L.latLng(coords.LatOri, coords.LonOri),
                zero: L.latLng(coords.LatZero, coords.LonZero),
                maxAngle: [coords.LatMaxAngle, coords.LonMaxAngle],
                pivot: L.latLng(coords.LatPiv, coords.LonPiv)
            };

            // Marqueur pour le pivot
            L.marker(points.pivot).addTo(map).bindPopup('Pivot');
            if (coords.PivCirc === 0) {
                L.polyline([points.origine, points.maxAngle], { color: 'red', dashArray: '5, 5' }).addTo(map);
            }

            // Lignes de référence
            L.polyline([points.origine, points.zero], { color: 'blue', dashArray: '5, 5' }).addTo(map);
            L.polyline([points.origine, points.pivot], { color: 'blue' }).addTo(map);

            // Fonction pour dessiner un arc avec remplissage
            function drawFilledArc(center, startPoint, endPoint, color = 'lightblue', opacity = 1) {
                const toPoint = latlng => map.latLngToLayerPoint(latlng);
                const toLatLng = point => map.layerPointToLatLng(point);

                // Conversion des coordonnées géographiques en points de la carte (pixels)
                const centerPoint = toPoint(center);
                const startPointPx = toPoint(startPoint);
                const endPointPx = toPoint(endPoint);

                // Calcul des rayons pour startPoint et endPoint
                const radiusStart = centerPoint.distanceTo(startPointPx);
                const radiusEnd = centerPoint.distanceTo(endPointPx);

                // Calcul des angles pour l'arc
                const angleStart = Math.atan2(startPointPx.y - centerPoint.y, startPointPx.x - centerPoint.x);
                const angleEnd = Math.atan2(endPointPx.y - centerPoint.y, endPointPx.x - centerPoint.x);

                // Ajustement de l'angle pour garantir un tracé correct
                let angleDiff = angleEnd - angleStart;
                if (angleDiff < 0) angleDiff += 2 * Math.PI;

                // Liste des points pour l'arc
                const points = [center];
                const numPoints = 100; // Nombre de segments pour lisser l'arc

                for (let i = 0; i <= numPoints; i++) {
                    // Calcul de l'angle interpolé entre start et end
                    const angle = angleStart + (angleDiff * (i / numPoints));

                    // Interpolation du rayon entre radiusStart et radiusEnd
                    const radius = radiusStart + (radiusEnd - radiusStart) * (i / numPoints);

                    // Calcul de la position en pixels en fonction de l'angle et du rayon
                    const pointPx = L.point({
                        x: centerPoint.x + radius * Math.cos(angle),
                        y: centerPoint.y + radius * Math.sin(angle)
                    });

                    // Conversion en coordonnées géographiques pour Leaflet
                    points.push(toLatLng(pointPx));
                }

                // Dessin du polygone représentant l'arc
                L.polygon(points, {
                    color: color, // Bordure de l'arc
                    fillColor: color, // Couleur de remplissage
                    fillOpacity: opacity, // Opacité
                    weight: 1
                }).addTo(map);
            }

            // Appels conditionnels à `drawFilledArc()`
            const points = {
                origine: L.latLng(coords.LatOri, coords.LonOri),
                zero: L.latLng(coords.LatZero, coords.LonZero),
                maxAngle: [coords.LatMaxAngle, coords.LonMaxAngle],
                pivot: L.latLng(coords.LatPiv, coords.LonPiv)
            };

            if (coords.sens === 0) {
                drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5);
                drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
            } else if (coords.sens === 1 && coords.PivCirc === 0) {
                drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5);
                drawFilledArc(points.origine, points.maxAngle, points.pivot, '#fff941', 0.5);
                drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
            } else if (coords.sens === 2 && coords.PivCirc === 0) {
                drawFilledArc(points.origine, points.pivot, points.zero, '#fff941', 0.5);
                drawFilledArc(points.origine, points.maxAngle, points.pivot, 'lightblue', 0.5);
                drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
            } else if (coords.sens === 1 && coords.PivCirc === 1) {
                drawFilledArc(points.origine, points.pivot, points.zero, '#fff941', 0.5);
                drawFilledArc(points.origine, points.zero, points.pivot, 'lightblue', 0.5);
                drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
            } else if (coords.sens === 2 && coords.PivCirc === 1) {
                drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5);
                drawFilledArc(points.origine, points.zero, points.pivot, '#fff941', 0.5);
                drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
            }

            // Ajustement de la vue sur la carte
            const bounds = L.latLngBounds([
                points.origine,
                points.zero,
                points.pivot
            ]);
            map.fitBounds(bounds, { padding: [150, 150] });
            setTimeout(() => {
                map.setView(bounds.getCenter(), map.getZoom() - 0.1);
            }, 500);
        }

        // Fonction pour obtenir la météo
        async function fetchWeather(lat, lon) {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,relativehumidity_2m,windspeed_10m,precipitation_probability&timezone=auto`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                displayWeather(data);
            } catch (error) {
                weatherPanel.textContent = 'Erreur de chargement météo';
            }
        }

        function displayWeather(data) {
            const current = data.current_weather;
            weatherPanel.innerHTML = `
                <p>-Température : ${current.temperature}°C</p>
                <p>-Vent : ${current.windspeed_10m} km/h</p>
                <p>-Condition : ${current.weathercode}</p>`;
        }

        // Initialisation de la carte et récupération des données
        initMap();
        fetchWeather(coords.LatPiv, coords.LonPiv);

        // Rafraîchissement de la carte toutes les 30 secondes
        setInterval(() => {
            initMap(); // Reinitialise la carte avec les mêmes données
            fetchWeather(coords.LatPiv, coords.LonPiv); // Rafraîchit la météo
        }, 30000); // 30 secondes
    </script>
</body>
</html>
