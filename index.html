<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pivot Irrifrance</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        #map { height: 100vh; }
    </style>
</head>
<body>
    <div id="map"></div>
    <script>
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            const values = params.get('p')?.split(',').map(Number);
            return values && values.length === 10 ? {
                LatOri: values[0], LonOri: values[1], LatZero: values[2], LonZero: values[3],
                LatMaxAngle: values[4], LonMaxAngle: values[5], LatPiv: values[6], LonPiv: values[7],
                PivCirc: values[8], sens: values[9]
            } : null;
        }

        const coords = getQueryParams();
        const map = L.map('map').setView([coords.LatOri, coords.LonOri], 16);

        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '© Esri, Maxar, Earthstar Geographics'
        }).addTo(map);

        const points = {
            origine: L.latLng(coords.LatOri, coords.LonOri),
            zero: L.latLng(coords.LatZero, coords.LonZero),
            maxAngle: L.latLng(coords.LatMaxAngle, coords.LonMaxAngle),
            pivot: L.latLng(coords.LatPiv, coords.LonPiv)
        };

        // Ajout des marqueurs
        L.marker(points.origine).addTo(map).bindPopup('Pilonne');
        L.marker(points.pivot).addTo(map).bindPopup('Pivot');

        // Ajout des lignes
        L.polyline([points.origine, points.zero], { color: 'blue', dashArray: '5, 5' }).addTo(map);
        L.polyline([points.origine, points.pivot], { color: 'blue' }).addTo(map);
        if (coords.PivCirc === 0) {
            L.polyline([points.origine, points.maxAngle], { color: 'red', dashArray: '5, 5' }).addTo(map);
        }

        // Fonction pour dessiner un arc
        function drawFilledArc(center, startPoint, endPoint, color = 'lightblue', opacity = 1) {
            const toPoint = latlng => map.latLngToLayerPoint(latlng);
            const toLatLng = point => map.layerPointToLatLng(point);
            const centerPoint = toPoint(center);
            const startPointPx = toPoint(startPoint);
            const endPointPx = toPoint(endPoint);
            const radiusStart = centerPoint.distanceTo(startPointPx);
            const radiusEnd = centerPoint.distanceTo(endPointPx);
            const angleStart = Math.atan2(startPointPx.y - centerPoint.y, startPointPx.x - centerPoint.x);
            const angleEnd = Math.atan2(endPointPx.y - centerPoint.y, endPointPx.x - centerPoint.x);
            let angleDiff = angleEnd - angleStart;
            if (angleDiff < 0) angleDiff += 2 * Math.PI;
            const points = [center];
            const numPoints = 50;
            for (let i = 0; i <= numPoints; i++) {
                const angle = angleStart + (angleDiff * (i / numPoints));
                const radius = radiusStart + (radiusEnd - radiusStart) * (i / numPoints);
                const pointPx = L.point({
                    x: centerPoint.x + radius * Math.cos(angle),
                    y: centerPoint.y + radius * Math.sin(angle)
                });
                points.push(toLatLng(pointPx));
            }
            L.polygon(points, {
                color: color,
                fillColor: color,
                fillOpacity: opacity,
                weight: 1
            }).addTo(map);
        }

        // Affichage des arcs en fonction des paramètres
        if (coords.sens === 0) {
            drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5);
            drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
        } else if (coords.sens === 1 && coords.PivCirc === 0) {
            drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5);
            drawFilledArc(points.origine, points.maxAngle, points.pivot, '#fff941', 0.5);
            drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
        } else if (coords.sens === 2 && coords.PivCirc === 0) {
            drawFilledArc(points.origine, points.pivot, points.zero, '#fff941', 0.5);
            drawFilledArc(points.origine, points.maxAngle, points.pivot, 'lightblue', 0.5);
            drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
        } else if (coords.sens === 1 && coords.PivCirc === 1) {
            drawFilledArc(points.origine, points.pivot, points.zero, '#fff941', 0.5);
            drawFilledArc(points.origine, points.zero, points.pivot, 'lightblue', 0.5);
            drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
        } else if (coords.sens === 2 && coords.PivCirc === 1) {
            drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5);
            drawFilledArc(points.origine, points.zero, points.pivot, '#fff941', 0.5);
            drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4);
        }
    </script>
</body>
</html>
