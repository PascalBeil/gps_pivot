<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pivot Irrifrance</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<style>
#map { height: 100vh; width: 100%; }

#weather-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255,255,255,0.95);
    padding: 10px 14px;
    border-radius: 6px;
    font-family: Arial, sans-serif;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    z-index: 1000;
    max-width: 240px;
    font-size: 12px;
    line-height: 1.4;
    backdrop-filter: blur(3px);
    border: 1px solid #ddd;
}

.loading-indicator {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 10px 15px;
    border-radius: 5px;
    z-index: 2000;
    font-size: 12px;
    display: none;
}
</style>
</head>
<body>

<div id="map"></div>
<div id="loading-indicator" class="loading-indicator">
ðŸ”„ Chargement des images satellite...
</div>
<div id="weather-panel">Chargement mÃ©tÃ©o...</div>

<script>

// -------------------- UTILITAIRES --------------------

function calculateDistance(p1,p2){
const R=6371000;
const dLat=(p2.lat-p1.lat)*Math.PI/180;
const dLon=(p2.lng-p1.lng)*Math.PI/180;
const a=Math.sin(dLat/2)**2+
Math.cos(p1.lat*Math.PI/180)*Math.cos(p2.lat*Math.PI/180)*Math.sin(dLon/2)**2;
return R*(2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)));
}

function calculateAngle(center,point){
const dx=point.lng-center.lng;
const dy=point.lat-center.lat;
let angle=Math.atan2(dy,dx)*(180/Math.PI);
if(angle<0)angle+=360;
return angle;
}

// -------------------- PARAMETRES --------------------

function getQueryParams(){
const params=new URLSearchParams(window.location.search);
const values=params.get('p')?.split(',').map(Number);
if(!values||values.length<12)return null;

return{
LatOri:values[0],LonOri:values[1],
LatZero:values[2],LonZero:values[3],
LatMaxAngle:values[4],LonMaxAngle:values[5],
LatPiv:values[6],LonPiv:values[7],
PivCirc:values[8],sens:values[9],
lang:values[10],ang:values[11]
};
}

const coords=getQueryParams();
if(!coords)throw new Error("ParamÃ¨tres invalides");

// -------------------- CARTE --------------------

const map=L.map('map',{maxZoom:19,minZoom:10})
.setView([coords.LatOri,coords.LonOri],18);

L.tileLayer(
'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
{maxZoom:19}
).addTo(map);

// -------------------- POINTS --------------------

const points={
origine:L.latLng(coords.LatOri,coords.LonOri),
zero:L.latLng(coords.LatZero,coords.LonZero),
maxAngle:L.latLng(coords.LatMaxAngle,coords.LonMaxAngle),
pivot:L.latLng(coords.LatPiv,coords.LonPiv)
};

// -------------------- RAYON ACTION CORRIGÃ‰ --------------------

const originCircleRadius=
calculateDistance(points.origine,points.pivot);

const angleZero=calculateAngle(points.origine,points.zero);
const angleMax=calculateAngle(points.origine,points.maxAngle);

let startArcAngle=angleZero;
let endArcAngle=angleMax;

// Correction propre du sens
if((endArcAngle-startArcAngle+360)%360>180){
const tmp=startArcAngle;
startArcAngle=endArcAngle;
endArcAngle=tmp;
}

function drawArc(center,radius,startAngle,endAngle){
const pts=[];
const steps=120;
const startRad=startAngle*Math.PI/180;
const endRad=endAngle*Math.PI/180;
let diff=endRad-startRad;
if(diff<0)diff+=2*Math.PI;

for(let i=0;i<=steps;i++){
const angle=startRad+(diff*(i/steps));
const dx=(radius*Math.cos(angle))/(111320*Math.cos(center.lat*Math.PI/180));
const dy=(radius*Math.sin(angle))/110574;
pts.push(L.latLng(center.lat+dy,center.lng+dx));
}
return L.polyline(pts,{
color:'#FF00FF',
weight:4,
dashArray:'10,10'
}).addTo(map);
}

drawArc(points.origine,originCircleRadius,startArcAngle,endArcAngle);

// -------------------- SEGMENTS --------------------

L.polyline([points.origine,points.zero],{
color:'blue',
dashArray:'6,6',
weight:4
}).addTo(map);

L.polyline([points.origine,points.pivot],{
color:'#00FF00',
weight:8
}).addTo(map);

// -------------------- METEO TOUJOURS EXPANDED --------------------

const weatherPanel=document.getElementById('weather-panel');

async function fetchWeather(lat,lon){
const url=`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&timezone=auto`;
try{
const r=await fetch(url);
const data=await r.json();
displayWeather(data);
}catch{
weatherPanel.innerHTML="MÃ©tÃ©o indisponible";
}
}

function displayWeather(data){
if(!data.current_weather)return;
const w=data.current_weather;
const now=new Date();

weatherPanel.innerHTML=`
<div style="font-weight:bold;margin-bottom:6px;">Informations Pivot</div>
<div><strong>Date:</strong> ${now.toLocaleDateString('fr-FR')}</div>
<div><strong>Heure:</strong> ${now.toLocaleTimeString('fr-FR',{hour:'2-digit',minute:'2-digit'})}</div>
<div><strong>TempÃ©rature:</strong> ${w.temperature.toFixed(1)}Â°C</div>
<div><strong>Angle:</strong> ${coords.ang}Â°</div>
`;
}

fetchWeather(coords.LatOri,coords.LonOri);

console.log("Application corrigÃ©e et stabilisÃ©e.");
</script>
</body>
</html>
