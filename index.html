<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pivot Irrifrance</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        #map { 
            height: 100vh; 
            width: 100%;
        }
        /* [Tous les autres styles restent identiques] */
    </style>
</head>
<body>
    <div id="map"></div>

    <!-- [Tous les éléments HTML restent identiques] -->

    <script>
        // [Toutes les fonctions utilitaires et initialisation restent identiques jusqu'aux polygones]

        // =============================================================================
        // FONCTION POUR CRÉER UN SEGMENT ARRONDI VERS L'EXTÉRIEUR
        // =============================================================================

        function createRoundedSegment(startPoint, endPoint, centerPoint, numPoints = 10) {
            // Calculer le vecteur entre le centre et le milieu du segment
            const midPoint = L.latLng(
                (startPoint.lat + endPoint.lat) / 2,
                (startPoint.lng + endPoint.lng) / 2
            );
            
            // Calculer la direction perpendiculaire au segment (vers l'extérieur)
            const dx = endPoint.lng - startPoint.lng;
            const dy = endPoint.lat - startPoint.lat;
            
            // Calculer la normale (perpendiculaire)
            const normal = {
                x: -dy,
                y: dx
            };
            
            // Normaliser la normale
            const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
            if (length > 0) {
                normal.x /= length;
                normal.y /= length;
            }
            
            // Déterminer le sens (vers l'extérieur par rapport au centre)
            const toCenter = {
                x: centerPoint.lng - midPoint.lng,
                y: centerPoint.lat - midPoint.lat
            };
            
            // Produit scalaire pour déterminer si la normale pointe vers l'extérieur
            const dot = normal.x * toCenter.x + normal.y * toCenter.y;
            if (dot > 0) {
                // Inverser la normale si elle pointe vers l'intérieur
                normal.x = -normal.x;
                normal.y = -normal.y;
            }
            
            // Calculer la distance pour la courbure (proportionnelle à la longueur du segment)
            const segmentLength = Math.sqrt(dx * dx + dy * dy);
            const curveDistance = segmentLength * 0.1; // 10% de la longueur pour une courbure légère
            
            // Point de contrôle pour la courbe de Bézier quadratique
            const controlPoint = L.latLng(
                midPoint.lat + normal.y * curveDistance,
                midPoint.lng + normal.x * curveDistance
            );
            
            // Générer les points de la courbe
            const curvePoints = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                
                // Courbe de Bézier quadratique
                const lat = (1 - t) * (1 - t) * startPoint.lat + 
                           2 * (1 - t) * t * controlPoint.lat + 
                           t * t * endPoint.lat;
                
                const lng = (1 - t) * (1 - t) * startPoint.lng + 
                           2 * (1 - t) * t * controlPoint.lng + 
                           t * t * endPoint.lng;
                
                curvePoints.push(L.latLng(lat, lng));
            }
            
            return curvePoints;
        }

        // =============================================================================
        // APPLICATION DANS LE MODE PIVOTFLEX
        // =============================================================================

        function handlePivotFlexZones() {
            let polygone1, polygone2;
            
            if (coords.hasFlexParams && coords.flexActive === 1) {
                // Créer le segment arrondi entre pivot et maxAngle
                const roundedSegment = createRoundedSegment(points.pivot, points.maxAngle, points.origine, 15);
                
                polygone1 = [points.origine, points.zero, points.pivot, points.flex, points.origine];
                // Remplacer le segment droit par le segment arrondi
                polygone2 = [points.origine, points.flex, points.pivot, ...roundedSegment, points.origine];
            } else {
                // Mode pivot standard - pas d'arrondi
                polygone1 = [points.origine, points.zero, points.pivot, points.maxAngle, points.origine];
                polygone2 = [points.origine, points.pivot, points.maxAngle, points.origine];
            }
            
            let polygone1Color, polygone2Color;
            
            if (coords.sens === 0) {
                polygone1Color = polygone2Color = 'lightblue';
            } else if (coords.sens === 1) {
                polygone1Color = coords.PivCirc === 0 ? 'lightblue' : '#fff941';
                polygone2Color = coords.PivCirc === 0 ? '#fff941' : 'lightblue';
            } else if (coords.sens === 2) {
                polygone1Color = coords.PivCirc === 0 ? '#fff941' : 'lightblue';
                polygone2Color = coords.PivCirc === 0 ? 'lightblue' : '#fff941';
            }
            
            drawPolygon(polygone1, polygone1Color);
            drawPolygon(polygone2, polygone2Color);
        }

        // =============================================================================
        // LIGNES DE RÉFÉRENCE AVEC SEGMENT ARRONDI
        // =============================================================================

        // Lignes de référence PivotFlex
        if (coords.hasFlexParams && coords.flexActive === 1) {
            L.polyline([points.origine, points.flex], { 
                color: 'blue', 
                dashArray: '6, 6',
                weight: 3,
                opacity: 0.9,
                lineCap: 'round'
            }).addTo(map).bindPopup('Segment Origine à Flex');
            
            L.polyline([points.flex, points.pivot], { 
                color: 'blue',
                weight: 3,
                opacity: 0.9,
                lineCap: 'round'
            }).addTo(map).bindPopup('Segment Flex à Pivot');
            
            L.polyline([points.zero, points.pivot], { 
                color: 'blue',
                weight: 3,
                opacity: 0.9,
                lineCap: 'round'
            }).addTo(map).bindPopup('Segment Zéro à Pivot');
            
            // Segment arrondi entre pivot et maxAngle
            const roundedSegment = createRoundedSegment(points.pivot, points.maxAngle, points.origine, 15);
            L.polyline(roundedSegment, { 
                color: 'blue',
                weight: 3,
                opacity: 0.9,
                lineCap: 'round'
            }).addTo(map).bindPopup('Segment arrondi Pivot à MaxAngle');
        }

        // [Le reste du code reste identique]
    </script>
</body>
</html>
