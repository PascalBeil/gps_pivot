<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pivot Irrifrance</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        #map { 
            height: 100vh; 
            width: 100%;
        }
        #weather-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: Arial, sans-serif;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            max-width: 180px;
            font-size: 12px;
            line-height: 1.3;
            backdrop-filter: blur(3px);
            border: 1px solid #ddd;
        }
        .weather-compact {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .weather-expanded {
            max-width: 220px;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 8px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            max-width: 150px;
            font-size: 11px;
            border: 1px solid #ddd;
        }
        .legend.collapsed {
            width: auto;
            padding: 4px 8px;
        }
        .legend-header {
            font-weight: bold;
            margin-bottom: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .legend-content {
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .legend.collapsed .legend-content {
            max-height: 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        .legend-color {
            width: 12px;
            height: 8px;
            margin-right: 6px;
            border: 1px solid #666;
            flex-shrink: 0;
        }
        .toggle-icon {
            font-size: 10px;
            margin-left: 5px;
        }
        .compact-view {
            display: block;
            font-size: 10px;
            color: #666;
        }
        .legend:not(.collapsed) .compact-view {
            display: none;
        }
        .weather-toggle {
            cursor: pointer;
            font-size: 10px;
            color: #0066cc;
            text-align: right;
            margin-top: 4px;
        }
        /* Style personnalis√© pour le marqueur pivot - VIOLET */
        .pivot-marker {
            background-color: #8A2BE2; /* Violet */
            border: 2px solid #ffffff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        /* Style pour l'ic√¥ne du point de d√©part */
        .pivot-icon {
            background: transparent;
            border: none;
        }
        /* Style pour le point de flexion */
        .flex-marker {
            background-color: #FF6B00; /* Orange */
            border: 2px solid #ffffff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        .error-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            text-align: center;
            max-width: 400px;
        }
        .debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 10px;
            z-index: 1000;
            max-width: 300px;
        }
        .zoom-save-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .zoom-save-indicator.show {
            opacity: 1;
        }
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 2000;
            font-size: 12px;
            display: none;
        }
        .tile-error-message {
            position: absolute;
            bottom: 50px;
            left: 10px;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 11px;
            max-width: 250px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <!-- Indicateur de chargement -->
    <div id="loading-indicator" class="loading-indicator">
        üîÑ Chargement des images satellite...
    </div>

    <!-- Message d'erreur tuiles -->
    <div id="tile-error-message" class="tile-error-message">
        ‚ö†Ô∏è Zoom trop √©lev√© - R√©solution non disponible
    </div>

    <!-- Panel de debug (optionnel) -->
    <div id="debug-panel" class="debug-panel" style="display: none;">
        R√©solution: <span id="resolution-info"></span><br>
        Zoom: <span id="zoom-info"></span>/<span id="max-zoom-info"></span><br>
        Tuiles charg√©es: <span id="tiles-loaded"></span><br>
        Statut: <span id="tile-status"></span>
    </div>

    <!-- Indicateur de sauvegarde du zoom -->
    <div id="zoom-save-indicator" class="zoom-save-indicator">Zoom sauvegard√©</div>

    <div id="weather-panel" class="weather-compact">Chargement...</div>
    <div class="legend collapsed" id="legend">
        <div class="legend-header">
            <span>L√©gende</span>
            <span class="toggle-icon">+</span>
        </div>
        <div class="legend-content">
            <div class="legend-item">
                <div class="legend-color" style="background-color: lightblue;"></div>
                <span>Zone irrigu√©e</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #fff941;"></div>
                <span>Zone √† irriguer</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: red;"></div>
                <span>Direction max</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: blue;"></div>
                <span>Lignes r√©f√©rence</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #8A2BE2;"></div>
                <span>Derni√®re tour</span>
            </div>
            <div class="legend-item" id="flex-legend-item" style="display: none;">
                <div class="legend-color" style="background-color: #FF6B00;"></div>
                <span>Point de flexion</span>
            </div>
        </div>
        <div class="compact-view">L√©gende (cliquer pour d√©velopper)</div>
    </div>
    
    <script>
        // =============================================================================
        // AM√âLIORATIONS POUR LE CHARGEMENT DES TUILES
        // =============================================================================

        // Variables pour le suivi des tuiles
        let tilesLoaded = 0;
        let tilesError = 0;
        let tileLoadTimeout;

        // Fonction pour montrer l'indicateur de chargement
        function showLoadingIndicator() {
            const loader = document.getElementById('loading-indicator');
            loader.style.display = 'block';
        }

        // Fonction pour cacher l'indicateur de chargement
        function hideLoadingIndicator() {
            const loader = document.getElementById('loading-indicator');
            loader.style.display = 'none';
        }

        // Fonction pour montrer l'erreur de tuiles
        function showTileError(message) {
            const errorMsg = document.getElementById('tile-error-message');
            errorMsg.textContent = message;
            errorMsg.style.display = 'block';
            setTimeout(() => {
                errorMsg.style.display = 'none';
            }, 5000);
        }

        // Suivi du chargement des tuiles
        function setupTileTracking() {
            tilesLoaded = 0;
            tilesError = 0;
            
            // Mettre √† jour le debug panel
            updateTileDebugInfo();
        }

        // Mettre √† jour les infos de debug des tuiles
        function updateTileDebugInfo() {
            if (document.getElementById('debug-panel').style.display !== 'none') {
                document.getElementById('tiles-loaded').textContent = `${tilesLoaded} (erreurs: ${tilesError})`;
                document.getElementById('zoom-info').textContent = map ? map.getZoom() : 'N/A';
                document.getElementById('max-zoom-info').textContent = map ? map.getMaxZoom() : 'N/A';
                
                const status = tilesError > tilesLoaded ? '‚ö†Ô∏è Probl√®mes' : '‚úÖ OK';
                document.getElementById('tile-status').textContent = status;
            }
        }

        // =============================================================================
        // GESTION DE LA SAUVEGARDE DU ZOOM
        // =============================================================================

        const ZOOM_STORAGE_KEY = 'pivot_irrifrance_zoom_level';

        function saveZoomLevel(zoom) {
            try {
                localStorage.setItem(ZOOM_STORAGE_KEY, zoom.toString());
                console.log(`‚úÖ Zoom sauvegard√©: ${zoom}`);
                showZoomSaveIndicator();
                updateDebugPanel();
            } catch (error) {
                console.error('‚ùå Erreur sauvegarde zoom:', error);
            }
        }

        function getSavedZoomLevel() {
            try {
                const savedZoom = localStorage.getItem(ZOOM_STORAGE_KEY);
                return savedZoom ? parseInt(savedZoom) : null;
            } catch (error) {
                console.error('‚ùå Erreur r√©cup√©ration zoom:', error);
                return null;
            }
        }

        function showZoomSaveIndicator() {
            const indicator = document.getElementById('zoom-save-indicator');
            indicator.classList.add('show');
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        // =============================================================================
        // D√âTECTION DE L'√âCRAN
        // =============================================================================

        function calculateOptimalZoom() {
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const pixelRatio = window.devicePixelRatio || 1;
            
            const effectiveWidth = screenWidth * pixelRatio;
            const effectiveHeight = screenHeight * pixelRatio;
            
            const estimatedDiagonal = Math.sqrt(Math.pow(screenWidth, 2) + Math.pow(screenHeight, 2)) / 
                                   (pixelRatio >= 2 ? 200 : 100);
            
            let baseZoom;
            
            if (estimatedDiagonal <= 7) {
                baseZoom = 19;
            } else if (estimatedDiagonal <= 10) {
                baseZoom = 18;
            } else if (estimatedDiagonal <= 13) {
                baseZoom = 17;
            } else if (estimatedDiagonal <= 15) {
                baseZoom = 16;
            } else if (estimatedDiagonal <= 24) {
                baseZoom = 15;
            } else {
                baseZoom = 14;
            }
            
            const densityAdjustment = Math.log2(pixelRatio);
            let optimalZoom = Math.min(19, Math.max(14, baseZoom + Math.round(densityAdjustment))); // LIMITE √Ä 19
            
            console.log(`üìê √âcran: ${Math.round(estimatedDiagonal)}", Zoom optimal: ${optimalZoom}`);
            
            return optimalZoom;
        }

        function updateDebugPanel() {
            if (document.getElementById('debug-panel').style.display !== 'none') {
                const screenWidth = window.screen.width;
                const screenHeight = window.screen.height;
                const pixelRatio = window.devicePixelRatio || 1;
                const effectiveWidth = screenWidth * pixelRatio;
                const effectiveHeight = screenHeight * pixelRatio;
                const estimatedDiagonal = Math.sqrt(Math.pow(screenWidth, 2) + Math.pow(screenHeight, 2)) / (pixelRatio >= 2 ? 200 : 100);
                
                document.getElementById('resolution-info').textContent = 
                    `${screenWidth}x${screenHeight} (${effectiveWidth}x${effectiveHeight})`;
                document.getElementById('zoom-info').textContent = 
                    map ? map.getZoom() : 'N/A';
                document.getElementById('max-zoom-info').textContent = 
                    '19 (limit√©)';
                document.getElementById('screen-size-info').textContent = 
                    `${Math.round(estimatedDiagonal)} pouces`;
            }
        }

        // =============================================================================
        // FONCTIONS PRINCIPALES
        // =============================================================================

        function getQueryParams() {
            try {
                const params = new URLSearchParams(window.location.search);
                const paramString = params.get('p');
                
                if (!paramString) {
                    console.error("‚ùå Param√®tre 'p' manquant");
                    return null;
                }
                
                const values = paramString.split(',').map(Number);
                
                if (values.length === 12) {
                    return {
                        LatOri: values[0], LonOri: values[1], LatZero: values[2], LonZero: values[3],
                        LatMaxAngle: values[4], LonMaxAngle: values[5], LatPiv: values[6], LonPiv: values[7],
                        PivCirc: values[8], sens: values[9], lang: values[10], ang: values[11],
                        flexActive: 0, hasFlexParams: false
                    };
                } else if (values.length === 15) {
                    return {
                        LatOri: values[0], LonOri: values[1], LatZero: values[2], LonZero: values[3],
                        LatMaxAngle: values[4], LonMaxAngle: values[5], LatPiv: values[6], LonPiv: values[7],
                        PivCirc: values[8], sens: values[9], lang: values[10], ang: values[11],
                        flexActive: values[12], LatFlex: values[13], LonFlex: values[14], hasFlexParams: true
                    };
                } else {
                    console.error("‚ùå Nombre de param√®tres incorrect:", values.length);
                    return null;
                }
            } catch (error) {
                console.error("‚ùå Erreur parsing param√®tres:", error);
                return null;
            }
        }

        const coords = getQueryParams();
        
        if (!coords) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-panel';
            errorDiv.innerHTML = `
                <h3>Erreur de param√®tres</h3>
                <p>L'URL ne contient pas les param√®tres attendus.</p>
                <p><strong>Format attendu:</strong></p>
                <p>?p=LatOri,LonOri,LatZero,LonZero,LatMaxAngle,LonMaxAngle,LatPiv,LonPiv,PivCirc,sens,lang,ang</p>
                <p style="margin-top: 15px; font-size: 12px; color: #666;">
                    V√©rifiez la console du navigateur (F12) pour plus de d√©tails.
                </p>
            `;
            document.body.appendChild(errorDiv);
            throw new Error("Param√®tres manquants ou incorrects");
        }

        // =============================================================================
        // INITIALISATION DE LA CARTE AVEC GESTION AM√âLIOR√âE DES TUILES
        // =============================================================================

        const savedZoom = getSavedZoomLevel();
        const optimalZoom = calculateOptimalZoom();
        const initialZoom = savedZoom !== null ? Math.min(savedZoom, 19) : optimalZoom; // LIMITE √Ä 19
        
        console.log(`üéØ Zoom initial: ${initialZoom} (sauvegard√©: ${savedZoom}, optimal: ${optimalZoom})`);

        // Initialisation de la carte avec limite de zoom
        const map = L.map('map', { 
            minZoom: 10, 
            maxZoom: 19, // LIMITE MAXIMUM FIX√âE √Ä 19
            zoomControl: true,
            fadeAnimation: true,
            zoomAnimation: true,
            markerZoomAnimation: true
        }).setView([coords.LatOri, coords.LonOri], initialZoom);

        // =============================================================================
        // COUCHE ESRI AVEC GESTION DES ERREURS AM√âLIOR√âE
        // =============================================================================

        // Couche Esri principale avec gestion d'erreur
        const esriLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '¬© Esri, Maxar, Earthstar Geographics',
            maxZoom: 19, // Correspond au maxZoom de la carte
            minZoom: 0,
            errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=', // Tuile transparente en cas d'erreur
            crossOrigin: true
        });

        // Couche de fallback (OpenStreetMap) en cas de probl√®mes
        const osmFallback = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19,
            minZoom: 0
        });

        // Gestionnaires d'√©v√©nements pour les tuiles
        esriLayer.on('loading', function() {
            showLoadingIndicator();
            setupTileTracking();
        });

        esriLayer.on('load', function() {
            tilesLoaded++;
            updateTileDebugInfo();
        });

        esriLayer.on('tileerror', function(e) {
            tilesError++;
            console.warn('‚ùå Erreur tuile:', e);
            updateTileDebugInfo();
            
            // Afficher un message si trop d'erreurs
            if (tilesError > 3) {
                showTileError('R√©solution satellite non disponible √† ce zoom');
            }
            
            // Cacher le loader apr√®s un d√©lai
            clearTimeout(tileLoadTimeout);
            tileLoadTimeout = setTimeout(hideLoadingIndicator, 1000);
        });

        esriLayer.on('tileload', function() {
            tilesLoaded++;
            updateTileDebugInfo();
            
            // Cacher le loader si suffisamment de tuiles sont charg√©es
            if (tilesLoaded >= 4) {
                clearTimeout(tileLoadTimeout);
                tileLoadTimeout = setTimeout(hideLoadingIndicator, 500);
            }
        });

        // Ajouter la couche principale
        esriLayer.addTo(map);

        // =============================================================================
        // GESTIONNAIRES D'√âV√âNEMENTS POUR LA CARTE
        // =============================================================================

        let zoomSaveTimeout;
        map.on('zoomstart', function() {
            showLoadingIndicator();
        });

        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            
            // Emp√™cher le zoom au-del√† de 19
            if (currentZoom > 19) {
                map.setZoom(19);
                showTileError('Zoom maximum atteint (limite technique)');
                return;
            }
            
            clearTimeout(zoomSaveTimeout);
            zoomSaveTimeout = setTimeout(() => {
                saveZoomLevel(currentZoom);
                updateDebugPanel();
            }, 500);
            
            // Cacher le loader apr√®s le zoom
            setTimeout(hideLoadingIndicator, 1000);
        });

        map.on('moveend', function() {
            const currentZoom = map.getZoom();
            clearTimeout(zoomSaveTimeout);
            zoomSaveTimeout = setTimeout(() => {
                saveZoomLevel(currentZoom);
                updateDebugPanel();
            }, 1000);
        });

        // Emp√™cher le zoom excessif avec la molette
        map.on('zoomlevelschange', function() {
            if (map.getZoom() > 19) {
                map.setZoom(19);
            }
        });

        // =============================================================================
        // SUITE DU CODE (marqueurs, polygones, etc.)
        // =============================================================================

        // [Le reste du code pour les points, marqueurs, polygones reste identique...]
        const points = {
            origine: L.latLng(coords.LatOri, coords.LonOri),
            zero: L.latLng(coords.LatZero, coords.LonZero),
            maxAngle: L.latLng(coords.LatMaxAngle, coords.LonMaxAngle),
            pivot: L.latLng(coords.LatPiv, coords.LonPiv)
        };

        if (coords.hasFlexParams && coords.flexActive === 1) {
            points.flex = L.latLng(coords.LatFlex, coords.LonFlex);
        }

        // Cr√©ation de l'ic√¥ne personnalis√©e
        const pivotIconSVG = `data:image/svg+xml;base64,${btoa(`
            <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                <circle cx="16" cy="16" r="14" fill="#4A90E2" stroke="#FFFFFF" stroke-width="2"/>
                <circle cx="16" cy="16" r="6" fill="#FFFFFF"/>
                <path d="M16 6 L16 26 M6 16 L26 16" stroke="#FFFFFF" stroke-width="2"/>
                <path d="M16 6 L12 10 M16 6 L20 10" stroke="#FFFFFF" stroke-width="2"/>
            </svg>
        `)}`;

        const startPointIcon = L.divIcon({
            className: 'pivot-icon',
            html: `<img src="${pivotIconSVG}" width="24" height="24" style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));">`,
            iconSize: [24, 24],
            iconAnchor: [12, 12]
        });

        // Marqueurs
        L.marker(points.origine, { icon: startPointIcon }).addTo(map).bindPopup('Point de d√©part du pivot');

        const pivotIcon = L.divIcon({
            className: 'pivot-marker',
            html: '',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        L.marker(points.pivot, { icon: pivotIcon }).addTo(map).bindPopup('Derni√®re tour du pivot');

        if (coords.hasFlexParams && coords.flexActive === 1) {
            const flexIcon = L.divIcon({
                className: 'flex-marker',
                html: '',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
            L.marker(points.flex, { icon: flexIcon }).addTo(map).bindPopup('Point de flexion du pivotflex');
            document.getElementById('flex-legend-item').style.display = 'flex';
        }

        // Lignes et polygones
        if (coords.PivCirc === 0) {
            L.polyline([points.origine, points.maxAngle], { 
                color: 'red', dashArray: '10, 10', weight: 3, opacity: 0.8 
            }).addTo(map).bindPopup('Direction maximale');
        }

        L.polyline([points.origine, points.zero], { 
            color: 'blue', weight: 2, opacity: 0.8 
        }).addTo(map).bindPopup('Segment Origine √† Z√©ro');

        // [Les fonctions drawPolygon, drawFilledArc, handlePivotFlexZones restent identiques...]
        function drawPolygon(pointList, color) {
            return L.polygon(pointList, {
                color: 'transparent', fillColor: color, fillOpacity: 0.6, weight: 0
            }).addTo(map);
        }

        function drawFilledArc(center, startPoint, endPoint, color = 'lightblue', opacity = 0.6) {
            const toPoint = latlng => map.latLngToLayerPoint(latlng);
            const toLatLng = point => map.layerPointToLatLng(point);

            const centerPoint = toPoint(center);
            const startPointPx = toPoint(startPoint);
            const endPointPx = toPoint(endPoint);

            const radiusStart = centerPoint.distanceTo(startPointPx);
            const radiusEnd = centerPoint.distanceTo(endPointPx);

            const angleStart = Math.atan2(startPointPx.y - centerPoint.y, startPointPx.x - centerPoint.x);
            const angleEnd = Math.atan2(endPointPx.y - centerPoint.y, endPointPx.x - centerPoint.x);

            let angleDiff = angleEnd - angleStart;
            if (angleDiff < 0) angleDiff += 2 * Math.PI;

            const arcPoints = [center];
            const numPoints = 100;

            for (let i = 0; i <= numPoints; i++) {
                const angle = angleStart + (angleDiff * (i / numPoints));
                const radius = radiusStart + (radiusEnd - radiusStart) * (i / numPoints);
                
                const pointPx = L.point({
                    x: centerPoint.x + radius * Math.cos(angle),
                    y: centerPoint.y + radius * Math.sin(angle)
                });
                arcPoints.push(toLatLng(pointPx));
            }

            return L.polygon(arcPoints, {
                color: 'transparent', fillColor: color, fillOpacity: opacity, weight: 0
            }).addTo(map);
        }

        function handlePivotFlexZones() {
            const polygone1 = [points.origine, points.zero, points.pivot, points.flex, points.origine];
            const polygone2 = [points.origine, points.flex, points.pivot, points.maxAngle, points.origine];
            
            let polygone1Color, polygone2Color;
            
            if (coords.sens === 0) {
                polygone1Color = polygone2Color = 'lightblue';
            } else if (coords.sens === 1) {
                polygone1Color = coords.PivCirc === 0 ? 'lightblue' : '#fff941';
                polygone2Color = coords.PivCirc === 0 ? '#fff941' : 'lightblue';
            } else if (coords.sens === 2) {
                polygone1Color = coords.PivCirc === 0 ? '#fff941' : 'lightblue';
                polygone2Color = coords.PivCirc === 0 ? 'lightblue' : '#fff941';
            }
            
            drawPolygon(polygone1, polygone1Color);
            drawPolygon(polygone2, polygone2Color);
        }

        // Gestion des sc√©narios
        if (coords.hasFlexParams && coords.flexActive === 1) {
            handlePivotFlexZones();
        } else {
            if (coords.sens === 0) {
                drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.6);
            } else if (coords.sens === 1 && coords.PivCirc === 0) {
                drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.6);
                drawFilledArc(points.origine, points.maxAngle, points.pivot, '#fff941', 0.6);
            } else if (coords.sens === 2 && coords.PivCirc === 0) {
                drawFilledArc(points.origine, points.pivot, points.zero, '#fff941', 0.6);
                drawFilledArc(points.origine, points.maxAngle, points.pivot, 'lightblue', 0.6);
            } else if (coords.sens === 1 && coords.PivCirc === 1) {
                drawFilledArc(points.origine, points.pivot, points.zero, '#fff941', 0.6);
                drawFilledArc(points.origine, points.zero, points.pivot, 'lightblue', 0.6);
            } else if (coords.sens === 2 && coords.PivCirc === 1) {
                drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.6);
                drawFilledArc(points.origine, points.zero, points.pivot, '#fff941', 0.6);
            }
        }

        // Ajustement final
        const boundsPoints = [points.origine, points.zero, points.pivot, points.maxAngle];
        if (coords.hasFlexParams && coords.flexActive === 1) {
            boundsPoints.push(points.flex);
        }
        
        const bounds = L.latLngBounds(boundsPoints);
        
        if (!savedZoom) {
            setTimeout(() => {
                const boundsZoom = map.getBoundsZoom(bounds, false);
                const estimatedDiagonal = Math.sqrt(Math.pow(window.screen.width, 2) + Math.pow(window.screen.height, 2)) / (window.devicePixelRatio >= 2 ? 200 : 100);
                let finalZoom = Math.min(optimalZoom, boundsZoom);
                
                // Ne pas d√©passer 19
                finalZoom = Math.min(finalZoom, 19);
                
                map.fitBounds(bounds, { padding: [15, 15], maxZoom: finalZoom });
                saveZoomLevel(finalZoom);
                
                console.log(`üéØ Ajustement final - Zoom: ${finalZoom}`);
            }, 200);
        }

        // =============================================================================
        // M√âT√âO ET INTERFACE
        // =============================================================================

        // [Le code m√©t√©o et interface reste identique...]
        const legend = document.getElementById('legend');
        const legendHeader = legend.querySelector('.legend-header');
        const toggleIcon = legend.querySelector('.toggle-icon');

        legendHeader.addEventListener('click', function() {
            const isCollapsed = legend.classList.toggle('collapsed');
            toggleIcon.textContent = isCollapsed ? '+' : '‚àí';
        });

        const weatherPanel = document.getElementById('weather-panel');
        let isWeatherExpanded = false;

        weatherPanel.addEventListener('click', function() {
            isWeatherExpanded = !isWeatherExpanded;
            weatherPanel.classList.toggle('weather-expanded', isWeatherExpanded);
            updateWeatherDisplay();
        });

        async function fetchWeather(lat, lon) {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&timezone=auto`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Erreur r√©seau');
                const data = await response.json();
                displayWeather(data);
            } catch (error) {
                console.error('Erreur m√©t√©o:', error);
                weatherPanel.textContent = 'M√©t√©o non disponible';
            }
        }

        function displayWeather(data) {
            const current = data.current_weather;
            window.weatherData = {
                temperature: current.temperature,
                weatherCode: current.weathercode,
                time: new Date()
            };
            updateWeatherDisplay();
        }

        function updateWeatherDisplay() {
            if (!window.weatherData) return;
            // [Code m√©t√©o identique...]
        }

        // Chargement des donn√©es m√©t√©o
        fetchWeather(coords.LatOri, coords.LonOri);

        // Debug
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F2') {
                e.preventDefault();
                const debugPanel = document.getElementById('debug-panel');
                debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
                updateDebugPanel();
                updateTileDebugInfo();
            }
        });

        function resetSavedZoom() {
            localStorage.removeItem(ZOOM_STORAGE_KEY);
            console.log('üóëÔ∏è Zoom r√©initialis√©');
            location.reload();
        }

        window.resetSavedZoom = resetSavedZoom;
        updateDebugPanel();
    </script>
</body>
</html>
