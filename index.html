<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pivot Irrifrance</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        #map { 
            height: 100vh; 
            width: 100%;
        }
        #weather-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            min-width: 200px;
            max-width: 300px;
            backdrop-filter: blur(5px);
        }
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 20px;
            height: 10px;
            margin-right: 8px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="weather-panel">Chargement météo...</div>
    <div class="legend" id="legend"></div>
    
    <script>
        // Fonction pour récupérer les paramètres d'URL
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            const values = params.get('p')?.split(',').map(Number);

            return values && values.length === 12 ? {
                LatOri: values[0],
                LonOri: values[1],
                LatZero: values[2],
                LonZero: values[3],
                LatMaxAngle: values[4],
                LonMaxAngle: values[5],
                LatPiv: values[6],
                LonPiv: values[7],
                PivCirc: values[8],
                sens: values[9],
                lang: values[10],
                ang: values[11]
            } : null;
        }

        const coords = getQueryParams();
        
        // Message d'erreur si pas de coordonnées
        if (!coords) {
            document.body.innerHTML = '<div style="padding: 20px; text-align: center;">Erreur : Paramètres manquants ou incorrects</div>';
            throw new Error("Paramètres manquants");
        }

        // Initialisation de la carte
        const map = L.map('map', { 
            minZoom: 0, 
            maxZoom: 22 
        }).setView([coords.LatOri, coords.LonOri], 16);

        // Couches de carte
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '© Esri, Maxar, Earthstar Geographics',
            maxZoom: 22
        }).addTo(map);

        // Définition des points géographiques
        const points = {
            origine: L.latLng(coords.LatOri, coords.LonOri),
            zero: L.latLng(coords.LatZero, coords.LonZero),
            maxAngle: L.latLng(coords.LatMaxAngle, coords.LonMaxAngle),
            pivot: L.latLng(coords.LatPiv, coords.LonPiv)
        };

        // Ajout des marqueurs
        L.marker(points.origine).addTo(map).bindPopup('Point d\'origine');
        L.marker(points.zero).addTo(map).bindPopup('Point zéro');
        L.marker(points.pivot).addTo(map).bindPopup('Position du pivot');

        // Ligne pointillée rouge si PivCirc = 0
        if (coords.PivCirc === 0) {
            L.polyline([points.origine, points.maxAngle], { 
                color: 'red', 
                dashArray: '5, 5',
                weight: 2
            }).addTo(map).bindPopup('Direction maximale');
        }

        // Lignes de référence bleues
        L.polyline([points.origine, points.zero], { 
            color: 'blue', 
            dashArray: '5, 5',
            weight: 2 
        }).addTo(map).bindPopup('Axe de référence');
        
        L.polyline([points.origine, points.pivot], { 
            color: 'blue',
            weight: 2 
        }).addTo(map).bindPopup('Direction actuelle du pivot');

        // Fonction pour dessiner des arcs remplis
        function drawFilledArc(center, startPoint, endPoint, color = 'lightblue', opacity = 1) {
            const toPoint = latlng => map.latLngToLayerPoint(latlng);
            const toLatLng = point => map.layerPointToLatLng(point);

            const centerPoint = toPoint(center);
            const startPointPx = toPoint(startPoint);
            const endPointPx = toPoint(endPoint);

            const radiusStart = centerPoint.distanceTo(startPointPx);
            const radiusEnd = centerPoint.distanceTo(endPointPx);

            const angleStart = Math.atan2(startPointPx.y - centerPoint.y, startPointPx.x - centerPoint.x);
            const angleEnd = Math.atan2(endPointPx.y - centerPoint.y, endPointPx.x - centerPoint.x);

            let angleDiff = angleEnd - angleStart;
            if (angleDiff < 0) angleDiff += 2 * Math.PI;

            const arcPoints = [center];
            const numPoints = 100;

            for (let i = 0; i <= numPoints; i++) {
                const angle = angleStart + (angleDiff * (i / numPoints));
                const radius = radiusStart + (radiusEnd - radiusStart) * (i / numPoints);
                
                const pointPx = L.point({
                    x: centerPoint.x + radius * Math.cos(angle),
                    y: centerPoint.y + radius * Math.sin(angle)
                });

                arcPoints.push(toLatLng(pointPx));
            }

            return L.polygon(arcPoints, {
                color: color,
                fillColor: color,
                fillOpacity: opacity,
                weight: 1
            }).addTo(map);
        }

        // Gestion des différents scénarios d'arcs
        let arcs = [];
        
        if (coords.sens === 0) {
            arcs.push(drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5));
        } else if (coords.sens === 1 && coords.PivCirc === 0) {
            arcs.push(drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5));
            arcs.push(drawFilledArc(points.origine, points.maxAngle, points.pivot, '#fff941', 0.5));
        } else if (coords.sens === 2 && coords.PivCirc === 0) {
            arcs.push(drawFilledArc(points.origine, points.pivot, points.zero, '#fff941', 0.5));
            arcs.push(drawFilledArc(points.origine, points.maxAngle, points.pivot, 'lightblue', 0.5));
        } else if (coords.sens === 1 && coords.PivCirc === 1) {
            arcs.push(drawFilledArc(points.origine, points.pivot, points.zero, '#fff941', 0.5));
            arcs.push(drawFilledArc(points.origine, points.zero, points.pivot, 'lightblue', 0.5));
            arcs.push(drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4));
        } else if (coords.sens === 2 && coords.PivCirc === 1) {
            arcs.push(drawFilledArc(points.origine, points.pivot, points.zero, 'lightblue', 0.5));
            arcs.push(drawFilledArc(points.origine, points.zero, points.pivot, '#fff941', 0.5));
            arcs.push(drawFilledArc(points.origine, points.zero, points.maxAngle, 'red', 0.4));
        }

        // Ajustement de la vue de la carte
        const bounds = L.latLngBounds([
            points.origine,
            points.zero,
            points.pivot,
            points.maxAngle
        ]);
        
        map.fitBounds(bounds, { padding: [50, 50] });
        
        setTimeout(() => {
            if (map.getZoom() > 16) {
                map.setZoom(16);
            }
        }, 500);

        // Création de la légende
        function createLegend() {
            const legend = document.getElementById('legend');
            const legends = {
                0: { color: 'lightblue', text: 'Zone irriguée' },
                1: { color: '#fff941', text: 'Zone à irriguer' },
                2: { color: 'red', text: 'Direction max' },
                3: { color: 'blue', text: 'Lignes de référence' }
            };

            let legendHTML = '<h4 style="margin: 0 0 10px 0;">Légende</h4>';
            Object.values(legends).forEach(item => {
                legendHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: ${item.color};"></div>
                        <span>${item.text}</span>
                    </div>
                `;
            });
            
            legend.innerHTML = legendHTML;
        }

        createLegend();

        // Gestion de la météo
        async function fetchWeather(lat, lon) {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,relativehumidity_2m,windspeed_10m,precipitation_probability&timezone=auto`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Erreur réseau');
                const data = await response.json();
                displayWeather(data);
            } catch (error) {
                console.error('Erreur météo:', error);
                document.getElementById('weather-panel').textContent = 'Météo non disponible';
            }
        }

        function displayWeather(data) {
            const current = data.current_weather;
            const weatherPanel = document.getElementById('weather-panel');

            function updateTime() {
                const now = new Date();
                const date = now.toLocaleDateString('fr-FR');
                const heure = now.toLocaleTimeString('fr-FR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });

                const templates = {
                    0: { // Français
                        date: 'Date', time: 'Heure', temp: 'Température', 
                        weather: 'Météo', angle: 'Angle actuel'
                    },
                    1: { // Anglais
                        date: 'Date', time: 'Time', temp: 'Temperature',
                        weather: 'Weather', angle: 'Current angle'
                    },
                    2: { // Espagnol
                        date: 'Fecha', time: 'Hora', temp: 'Temperatura',
                        weather: 'Tiempo', angle: 'Ángulo actual'
                    },
                    3: { // Portugais
                        date: 'Data', time: 'Hora', temp: 'Temperatura',
                        weather: 'Tempo', angle: 'Ângulo actual'
                    },
                    4: { // Allemand
                        date: 'Datum', time: 'Uhrzeit', temp: 'Temperatur',
                        weather: 'Wetter', angle: 'Aktueller Winkel'
                    },
                    5: { // Néerlandais
                        date: 'Datum', time: 'Tijd', temp: 'Temperatuur',
                        weather: 'Weer', angle: 'Huidige hoek'
                    },
                    6: { // Italien
                        date: 'Data', time: 'Ora', temp: 'Temperatura',
                        weather: 'Condizioni', angle: 'Angolo attuale'
                    }
                };

                const t = templates[coords.lang] || templates[0];
                const weatherDesc = getWeatherDescription(current.weathercode, coords.lang);

                weatherPanel.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px;">Informations Pivot</div>
                    <p><strong>${t.date}:</strong> ${date}</p>
                    <p><strong>${t.time}:</strong> ${heure}</p>
                    <p><strong>${t.temp}:</strong> ${current.temperature.toFixed(1)}°C</p>
                    <p><strong>${t.weather}:</strong> ${weatherDesc}</p>
                    <p><strong>${t.angle}:</strong> ${coords.ang}°</p>
                `;
            }

            updateTime();
            setInterval(updateTime, 60000); // Mise à jour toutes les minutes
        }

        // Fonction de description météo multilingue
        function getWeatherDescription(code, lang) {
            const descriptions = {
                0: ['Ciel dégagé', 'Clear sky', 'Cielo despejado', 'Céu limpo', 'Klarer Himmel', 'Onbewolkte hemel', 'Cielo sereno'],
                1: ['Ciel dégagé', 'Clear sky', 'Cielo despejado', 'Céu limpo', 'Klarer Himmel', 'Onbewolkte hemel', 'Cielo sereno'],
                2: ['Partiellement nuageux', 'Partly cloudy', 'Parcialmente nublado', 'Parcialmente nublado', 'Teilweise bewölkt', 'Gedeeltelijk bewolkt', 'Parzialmente nuvoloso'],
                3: ['Couvert', 'Overcast', 'Cubierto', 'Encoberto', 'Bedeckt', 'Bewolkt', 'Coperto'],
                45: ['Brouillard', 'Fog', 'Niebla', 'Nevoeiro', 'Nebel', 'Mist', 'Nebbia'],
                48: ['Brouillard givrant', 'Freezing fog', 'Niebla helada', 'Nevoeiro congelante', 'Gefrierender Nebel', 'IJzelmist', 'Nebbia gelata'],
                51: ['Bruine légère', 'Light drizzle', 'Llovizna ligera', 'Chuvisco leve', 'Leichter Nieselregen', 'Lichte motregen', 'Pioviggine leggera'],
                53: ['Bruine modérée', 'Moderate drizzle', 'Llovizna moderada', 'Chuvisco moderado', 'Mäßiger Nieselregen', 'Matige motregen', 'Pioviggine moderata'],
                55: ['Bruine dense', 'Dense drizzle', 'Llovizna densa', 'Chuvisco denso', 'Dichter Nieselregen', 'Dichte motregen', 'Pioviggine densa'],
                61: ['Pluie légère', 'Light rain', 'Lluvia ligera', 'Chuva leve', 'Leichter Regen', 'Lichte regen', 'Pioggia leggera'],
                63: ['Pluie modérée', 'Moderate rain', 'Lluvia moderada', 'Chuva moderada', 'Mäßiger Regen', 'Matige regen', 'Pioggia moderata'],
                65: ['Pluie forte', 'Heavy rain', 'Lluvia fuerte', 'Chuva forte', 'Starker Regen', 'Zware regen', 'Pioggia forte'],
                71: ['Neige légère', 'Light snow', 'Nieve ligera', 'Neve leve', 'Leichter Schnee', 'Lichte sneeuw', 'Neve leggera'],
                73: ['Neige modérée', 'Moderate snow', 'Nieve moderada', 'Neve moderada', 'Mäßiger Schnee', 'Matige sneeuw', 'Neve moderata'],
                75: ['Neige forte', 'Heavy snow', 'Nieve fuerte', 'Neve forte', 'Starker Schnee', 'Zware sneeuw', 'Neve forte'],
                95: ['Orage', 'Thunderstorm', 'Tormenta', 'Trovoada', 'Gewitter', 'Onweer', 'Temporale']
            };

            return descriptions[code]?.[lang] || descriptions[code]?.[0] || 'Inconnu';
        }

        // Chargement des données météo
        fetchWeather(coords.LatOri, coords.LonOri);
    </script>
</body>
</html>
