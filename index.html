<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pivot Irrifrance</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        /* Votre CSS existant reste identique */
    </style>
</head>
<body>
    <!-- Votre HTML existant reste identique -->
    
    <script>
        // ... Tout le code précédent reste identique jusqu'au calcul du rayon ...

        // NOUVEAU CALCUL DU RAYON D'ACTION (demi-cercle magenta)
        let originCircleRadius;
        
        // Logique de calcul selon les conditions
        if (!coords.hasFlexParams && !coords.hasPafEscamParams) {
            // Ni flex ni porte-à-faux activés
            originCircleRadius = calculateDistance(points.origine, points.pivot);
        } else if (coords.hasFlexParams && coords.flexActive === 1 && (!coords.hasPafEscamParams || coords.pafEscamActive === 0)) {
            // Flex activé mais pas le porte-à-faux
            originCircleRadius = calculateDistance(points.origine, points.flex) + calculateDistance(points.flex, points.pivot);
        } else if (coords.hasFlexParams && coords.flexActive === 1 && coords.hasPafEscamParams && coords.pafEscamActive === 1) {
            // Flex et porte-à-faux activés
            originCircleRadius = calculateDistance(points.origine, points.flex) + calculateDistance(points.flex, points.pivot) + calculateDistance(points.pivot, points.pafEscam);
        } else if ((!coords.hasFlexParams || coords.flexActive === 0) && coords.hasPafEscamParams && coords.pafEscamActive === 1) {
            // Seulement le porte-à-faux activé
            originCircleRadius = calculateDistance(points.origine, points.pivot) + calculateDistance(points.pivot, points.pafEscam);
        } else {
            // Cas par défaut (sécurité)
            originCircleRadius = calculateDistance(points.origine, points.pivot);
        }

        const angleZero = calculateAngle(points.origine, points.zero);
        const angleMax = calculateAngle(points.origine, points.maxAngle);

        // RETOUR À LA LOGIQUE ORIGINALE POUR LES ANGLES (qui avait le bon sens)
        let startArcAngle, endArcAngle;
        let angleFromZeroToMax = (angleMax - angleZero + 360) % 360;
        
        if (angleFromZeroToMax <= 180) {
            startArcAngle = angleMax;
            endArcAngle = angleZero + 360;
        } else {
            startArcAngle = angleZero;
            endArcAngle = angleMax;
        }

        // CORRECTION : Ajustement des angles pour résoudre le problème de décalage
        // On ajoute un petit offset pour s'assurer que l'arc couvre bien toute la zone
        const angleOffset = 0.5; // 0.5 degré d'offset pour s'assurer que l'arc couvre bien les points
        startArcAngle -= angleOffset;
        endArcAngle += angleOffset;

        const originArc = drawArc(points.origine, originCircleRadius, startArcAngle, endArcAngle, {
            color: '#FF00FF',
            weight: 4,
            opacity: 1.0,
            dashArray: '10, 10',
            lineCap: 'round'
        }).addTo(map).bindPopup(`Rayon d'action - Distance: ${originCircleRadius.toFixed(2)} m`);

        document.getElementById('origin-circle-legend-item').style.display = 'flex';

        // ... Le reste de votre code reste identique ...
    </script>
</body>
</html>
